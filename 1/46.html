---
layout: "layout"
---
<h1>Linux is Obsolete</h1>

<h2>Pendahuluan</h2>
<p>
Ini merupakan <em>posting</em> favorit perihal Linux; yang terjadi 
awal 1992 yang lalu. 
Karena favorit, saya pernah <b>berkali-kali</b> 
<a href="http://www.parokinet.org/pau-mikro/1994/msg00847.html" target="_top">mem-post ulang</a>,
mudah-mudahan pada tidak bosan, deh.
Versi ini diedit di sana/ sini, dan juga ditambahkan beberapa URL 
yang terkait.

<pre>
/* Written 7:12 pm Jan 29, 1992 in ogah:comp.os.minix */
/* ---------- "LINUX is obsolete" ---------- */
</pre>
<p>
I was in the U.S. for a couple of weeks, so I haven&#39;t commented much on
<a href="http://www.linux.org/" target="_top">LINUX</a>
(not that I would have said much had I been around), but for what
it is worth, I have a couple of comments now.
<p>
As most of you know, for me 
<a href="http://www.cs.vu.nl/~ast/minix.html" target="_top">MINIX</a>
is a hobby, something that I do in the
evening when I get bored writing books and there are no major wars,
revolutions, or senate hearings being televised live on 
<a href="http://www.cnn.com/" target="_top">CNN</a>.
My real job is a professor and researcher in the area of operating systems.
<p>
As a result of my occupation, I think I know a bit about where operating
are going in the next decade or so. Two aspects stand out:
<p>
<ol>
<li><b>MICROKERNEL VS MONOLITHIC SYSTEM</b>
<p>
Most older operating systems are monolithic, that is, the whole operating
system is a single a.out file that runs in &#39;kernel mode.&#39; 
This binary contains the process management, memory management, 
file system and the rest. Examples of such systems are UNIX, MS-DOS, 
VMS, MVS, OS/360, MULTICS, and many more.
<p>
The alternative is a microkernel-based system, in which most of the OS
runs as separate processes, mostly outside the kernel. They communicate
by message passing. The kernel&#39;s job is to handle the 
message passing, interrupt handling, low-level process management, 
and possibly the I/O. Examples of this design are the RC4000, Amoeba, 
Chorus, Mach, and the not-yet-released Windows/NT.
<p>
While I could go into a long story here about the relative merits of the
two designs, suffice it to say that among the people who actually design
operating systems, the debate is essentially over. Microkernels have won.
The only real argument for monolithic systems was performance, and there
is now enough evidence showing that microkernel systems can be just as
fast as monolithic systems (e.g., Rick Rashid has published papers comparing
Mach 3.0 to monolithic systems) that it is now all over but the 
shoutin&#39;.
<p>
MINIX is a microkernel-based system. The file system and memory management
are separate processes, running outside the kernel. The I/O drivers are
also separate processes (in the kernel, but only because the brain-dead
nature of the Intel CPUs makes that difficult to do otherwise). LINUX is
a monolithic style system. This is a giant step back into the 1970s.
That is like taking an existing, working C program and rewriting it in
BASIC. To me, writing a monolithic system in 1991 is a truly poor idea.
<p>
<li><b>PORTABILITY</b>
<p>
Once upon a time there was the 4004 CPU. When it grew up it became an
8008. Then it underwent plastic surgery and became the 8080. It begat
the 8086, which begat the 8088, which begat the 80286, which begat the
80386, which begat the 80486, and so on unto the N-th generation. In
the meantime, RISC chips happened, and some of them are running at over
100 MIPS. Speeds of 200 MIPS and more are likely in the coming years.
These things are not going to suddenly vanish. What is going to happen
is that they will gradually take over from the 80x86 line. They will
run old MS-DOS programs by interpreting the 80386 in software. (I even
wrote my own IBM PC simulator in C, which you can get by FTP from
ftp.cs.vu.nl = 192.31.231.42 in dir minix/simulator.) I think it is a
gross error to design an OS for any specific architecture, since that is
not going to be around all that long.
<p>
MINIX was designed to be reasonably portable, and has been ported from the
Intel line to the 680x0 (Atari, Amiga, Macintosh), SPARC, and NS32016.
LINUX is tied fairly closely to the 80x86. Not the way to go.
</ol>
<p>
Don&#39;t get me wrong, I am not unhappy with LINUX. It will get 
all the people who want to turn MINIX in BSD UNIX off my back. 
But in all honesty, I would suggest that people who want a **MODERN** 
"free" OS look around for a microkernel-based, portable OS, like maybe 
<a href="http://gnu.vLSM.org/" target="_top">GNU</a>
or something like that.
<p>
Andy Tanenbaum (astATcs.vu.nl)
<p>
P.S. Just as a random aside, Amoeba has a UNIX emulator (running in user
space), but it is far from complete. If there are any people who would
like to work on that, please let me know. To run Amoeba you need a few 386s,
one of which needs 16M, and all of which need the WD Ethernet card.

<h2><a href="http://www.tuxedo.org/~esr/faqs/linus/" target="_top">Linus B. Torvalds</a> -- 30 January 1992</h2>
<p>
<pre>
/* Written 6:14 am Jan 30, 1992 in ogah:comp.os.minix */
</pre>
<p>
Well, with a subject like this, I&#39;m afraid I&#39;ll have to reply.
Apologies to minix-users who have heard enough about linux anyway. I&#39;d
like to be able to just "ignore the bait", but ... Time for some
serious flamefesting!
<p>
In article astATcs.vu.nl (Andy Tanenbaum) writes:
<pre>
&gt; As most of you know, for me MINIX is a hobby, something that 
&gt; I do in the evening when I get bored writing books and there 
&gt; are no major wars, revolutions, or senate hearings being 
&gt; televised live on CNN. My real job is a professor and researcher 
&gt; in the area of operating systems.
</pre>
<p>
You use this as an excuse for the limitations of minix? Sorry, but you
loose: I&#39;ve got more excuses than you have, and linux still beats the
pants of minix in almost all areas. Not to mention the fact that most
of the good code for PC minix seems to have been written by 
<em>Bruce Evans</em>.
<p>
Re 1: you doing minix as a hobby - look at who makes money off minix,
and who gives linux out for free. Then talk about hobbies. Make minix
freely available, and one of my biggest gripes with it will disappear.
Linux has very much been a hobby (but a serious one: the best type) for
me: I get no money for it, and it&#39;s not even part of any of my studies
in the university. I&#39;ve done it all on my own time, and on my own
machine.
<p>
Re 2: your job is being a professor and researcher: That&#39;s one hell of a
good excuse for some of the brain-damages of minix. I can only hope (and
assume) that Amoeba doesn&#39;t suck like minix does.
<p>
<pre>
&gt; 1. MICROKERNEL VS MONOLITHIC SYSTEM
</pre>
<p>
True, linux is monolithic, and I agree that microkernels are nicer. With
a less argumentative subject, I&#39;d probably have agreed with most of what
you said. From a theoretical (and aesthetical) standpoint linux looses.
If the GNU kernel had been ready last spring, I&#39;d not have bothered to
even start my project: 
<b>the fact is that it wasn&#39;t and still isn&#39;t</b>.
Linux wins heavily on points of being available now.
<p>
<pre>
&gt; MINIX is a microkernel-based system. [deleted, but not so 
&gt; that you miss the point ] LINUX is a monolithic style system.
</pre>
If this was the only criterion for the "goodness" of a kernel, you&#39;d be
right. What you don&#39;t mention is that minix doesn&#39;t do 
the micro-kernel thing very well, and has problems with real multitasking 
(in the kernel). If I had made an OS that had problems with a 
multithreading filesystem, I wouldn&#39;t be so fast to condemn others: 
in fact, I&#39;d do my damndest to make others forget about the fiasco.
<p>
[yes, I know there are multithreading hacks for minix, but they are
hacks, and bruce evans tells me there are lots of race conditions ]
<p>
<pre>
&gt; 2. PORTABILITY

"Portability is for people who cannot write new programs"
-me, right now (with tongue in cheek)
</pre>
The fact is that linux is more portable than minix. What? I hear you
say. It&#39;s true - but not in the sense that ast means: I made linux as
conformant to standards as I knew how (without having any POSIX standard
in front of me). Porting things to linux is generally /much/ easier
than porting them to minix.
<p>
I agree that portability is a good thing: but only where it actually has
some meaning. There is no idea in trying to make an operating system
overly portable: adhering to a portable API is good enough. The very
/idea/ of an operating system is to use the hardware features, and hide
them behind a layer of high-level calls. That is exactly what linux
does: it just uses a bigger subset of the 386 features than other
kernels seem to do. Of course this makes the kernel proper unportable,
but it also makes for a /much/ simpler design. An acceptable trade-off,
and one that made linux possible in the first place.
<p>
I also agree that linux takes the non-portability to an extreme: I got
my 386 last January, and linux was partly a project to teach me about
it. Many things should have been done more portably if it would have
been a real project. I&#39;m not making overly many excuses about it
though: it was a design decision, and last april when I started the
thing, I didn&#39;t think anybody would actually want to use it. 
I&#39;m happy to report I was wrong, and as my source is freely 
available, anybody is free to try to port it, even though it 
won&#39;t be easy.
<p>
Linus
<p>
PS. I apologise for sometimes sounding too harsh: minix is nice enough
if you have nothing else. Amoeba might be nice if you have 5-10 spare
386&#39;s lying around, but I certainly don&#39;t. I don&#39;t 
usually get into flames, but I&#39;m touchy when it comes to linux :) 

<h2>Andy S. Tanenbaum -- 30 January 1992</h2>
<p>
<pre>
/* Written Jan 30, 1992 in ogah:comp.os.minix */
</pre>
<p>
In article torvaldsATklaava.Helsinki.FI (Linus Benedict Torvalds) writes:
<pre>
&gt; You use this [being a professor] as an excuse for the limitations 
&gt; of minix?
</pre>
<p>
The limitations of MINIX relate at least partly to my being a professor:
An explicit design goal was to make it run on cheap hardware so students
could afford it. In particular, for years it ran on a regular 4.77 MHZ PC
with no hard disk. You could do everything here including modify and recompile
the system. Just for the record, as of about 1 year ago, there were two
versions, one for the PC (360K diskettes) and one for the 286/386 (1.2M).
The PC version was outselling the 286/386 version by 2 to 1. I don&#39;t have
figures, but my guess is that the fraction of the 60 million existing PCs that
are 386/486 machines as opposed to 8088/286/680x0 etc is small. Among students
it is even smaller. Making software free, but only for folks with enough money
to buy first class hardware is an interesting concept.
Of course 5 years from now that will be different, but 5 years from now
everyone will be running free GNU on their 200 MIPS, 64M SPARCstation-5.
<p>
<pre>
&gt; Re 2: your job is being a professor and researcher: That&#39;s one 
&gt; hell of a good excuse for some of the brain-damages of minix. I can 
&gt; only hope (and assume) that Amoeba doesn&#39;t suck like minix does.
</pre>
<p>
Amoeba was not designed to run on an 8088 with no hard disk.
<pre>
&gt; If this was the only criterion for the "goodness" of a kernel, 
&gt; you&#39;d be right. What you don&#39;t mention is that minix 
&gt; doesn&#39;t do the micro-kernel thing very well, and has problems 
&gt; with real multitasking (in the kernel). If I had made an OS that 
&gt; had problems with a multithreading filesystem, I wouldn&#39;t 
&gt; be so fast to condemn others: in fact, I&#39;d do my damndest to 
&gt; make others forget about the fiasco.
</pre>
<p>
A multithreaded file system is only a performance hack. When there is only
one job active, the normal case on a small PC, it buys you nothing and adds
complexity to the code. On machines fast enough to support multiple users,
you probably have enough buffer cache to insure a hit cache hit rate, in
which case multithreading also buys you nothing. It is only a win when there
are multiple processes actually doing real disk I/O. Whether it is worth
making the system more complicated for this case is at least debatable.
<p>
I still maintain the point that designing a monolithic kernel in 1991 is
a fundamental error. Be thankful you are not my student. You would not
get a high grade for such a design :-).
<p>
<pre>
&gt; The fact is that linux is more portable than minix. What? 
&gt; I hear you say. It&#39;s true - but not in the sense that ast 
&gt; means: I made linux as conformant to standards as I knew how 
&gt; (without having any POSIX standard in front of me). Porting 
&gt; things to linux is generally /much/ easier than porting them to 
&gt; minix.
</pre>
<p>
MINIX was designed before POSIX, and is now being (slowly) POSIXized as
everyone who follows this newsgroup knows. Everyone agrees that user-level
standards are a good idea. As an aside, I congratulate you for being able
to write a POSIX-conformant system without having the POSIX standard in front
of you. I find it difficult enough after studying the standard at great length.
<p>
My point is that writing a new operating system that is closely tied to any
particular piece of hardware, especially a weird one like the Intel line,
is basically wrong. An OS itself should be easily portable to new hardware
platforms. When OS/360 was written in assembler for the IBM 360
25 years ago, they probably could be excused. When MS-DOS was written
specifically for the 8088 ten years ago, this was less than brilliant, as
IBM and Microsoft now only too painfully realize. Writing a new OS only for the
386 in 1991 gets you your second &#39;F&#39; for this term. 
But if you do real well on the final exam, you can still pass the course.
<p>
Prof. Andrew S. Tanenbaum (astATcs.vu.nl)

<h2>Linus B. Torvalds -- 30 January 1992</h2>
<p>
<pre>
/* Written 10:38 pm Jan 30, 1992 in ogah:comp.os.minix */
</pre>
<p>
In article &lt;1992Jan29.231426.20469ATklaava.Helsinki.FI&gt; I wrote:
<p>
<pre>
&gt; Well, with a subject like this, I&#39;m afraid I&#39;ll have to reply.
</pre>
<p>
And reply I did, with complete abandon, and no thought for good taste
and netiquette. Apologies to ast, and thanks to John Nall for a friendy
"that&#39;s not how it&#39;s done"-letter. I over-reacted, and 
am now composing a (much less acerbic) personal letter to ast. 
Hope nobody was turned away from linux due to it being (a) possibly 
obsolete (I still think that&#39;s not the case, although some of 
the criticisms are valid) and (b) written by a hothead :-)
<p>
Linus "my first, and hopefully last flamefest" Torvalds


<h2>Linus B. Torvalds -- 31 January 1992</h2>
<p>
<pre>
/* Written 5:33 pm Jan 31, 1992 in ogah:comp.os.minix */
</pre>
<p>
In article &lt;12615ATstar.cs.vu.nl&gt; astATcs.vu.nl (Andy Tanenbaum) writes:
<pre>
&gt; The limitations of MINIX relate at least partly to my being a professor:
&gt; An explicit design goal was to make it run on cheap hardware so students
&gt; could afford it.
</pre>
<p>
All right: a real technical point, and one that made some of my comments
inexcusable. But at the same time you shoot yourself in the foot a bit:
now you admit that some of the errors of minix were that it was too
portable: including machines that weren&#39;t really designed to run unix.
That assumption lead to the fact that minix now cannot easily be
extended to have things like paging, even for machines that would
support it. Yes, minix is portable, but you can rewrite that as
"doesn&#39;t use any features", and still be right.
<p>
<pre>
&gt; A multithreaded file system is only a performance hack.
</pre>
<p>
Not true. It&#39;s a performance hack /on a microkernel/, but it&#39;s an
automatic feature when you write a monolithic kernel - one area where
microkernels don&#39;t work too well (as I pointed out in my personal mail
to ast). When writing a unix the "obsolete" way, you automatically get
a multithreaded kernel: every process does it&#39;s own job, and you 
don&#39;t have to make ugly things like message queues to make it work
efficiently.
<p>
Besides, there are people who would consider "only a performance hack"
vital: unless you have a cray-3, I&#39;d guess everybody gets tired of
waiting on the computer all the time. I know I did with minix (and yes,
I do with linux too, but it&#39;s /much/ better).
<p>
<pre>
&gt; I still maintain the point that designing a monolithic kernel 
&gt; in 1991 is a fundamental error. Be thankful you are not my 
&gt; student. You would not get a high grade for such a design :-)
</pre>
<p>
Well, I probably won&#39;t get too good grades even without you: I had an
argument (completely unrelated - not even pertaining to OS&#39;s) with the
person here at the university that teaches OS design. I wonder when
I&#39;ll learn :)
<pre>
&gt; My point is that writing a new operating system that is closely 
&gt; tied to any particular piece of hardware, especially a weird one 
&gt; like the Intel line, is basically wrong.
</pre>
<p>
But /my/ point is that the operating system /isn&#39;t/ tied to any
processor line: UNIX runs on most real processors in existence. Yes,
the /implementation/ is hardware-specific, but there&#39;s a HUGE
difference. You mention OS/360 and MS-DOG as examples of bad designs
as they were hardware-dependent, and I agree. But there&#39;s a big
difference between these and linux: linux API is portable (not due to my
clever design, but due to the fact that I decided to go for a fairly-
well-thought-out and tested OS: unix.)
<p>
If you write programs for linux today, you shouldn&#39;t have too many
surprises when you just recompile them for Hurd in the 21st century. As
has been noted (not only by me), the linux kernel is a miniscule part of
a complete system: Full sources for linux currently runs to about 200kB
compressed - full sources to a somewhat complete developement system is
at least 10MB compressed (and easily much, much more). And all of that
source is portable, except for this tiny kernel that you can (provably:
I did it) re-write totally from scratch in less than a year without
having /any/ prior knowledge.
<p>
In fact the /whole/ linux kernel is much smaller than the 386-dependent
things in mach: i386.tar.Z for the current version of mach is well over
800kB compressed (823391 bytes according to nic.funet.fi). Admittedly,
mach is "somewhat" bigger and has more features, but that should still
tell you something.
<p>
Linus

